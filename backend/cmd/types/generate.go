package main

import (
	"apinest/internal/db"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
	"gorm.io/gorm"
)

type PostgresType struct {
	TypeName string
	Values   []string
}

type DataMapEntry struct {
	PostgresType string
	GoType       string
}

// Initialize database connection.
func main() {
	database := db.GetInstance()

	// Clean enum folder
	cleanEnumFolder()

	// Fetch all custom enum types from PostgreSQL
	types, err := fetchCustomTypes(database)
	if err != nil {
		log.Fatalf("Failed to fetch custom types: %v", err)
	}

	fmt.Printf("Found %d custom types:\n", len(types))
	for _, t := range types {
		fmt.Printf("- %s: %v\n", t.TypeName, t.Values)
	}

	// Generate struct files for each type
	if err := generateStructFiles(types); err != nil {
		log.Fatalf("Failed to generate struct files: %v", err)
	}

	// Generate dataMap file
	if err := generateDataMap(types); err != nil {
		log.Fatalf("Failed to generate dataMap: %v", err)
	}

	fmt.Println("✅ Successfully generated all type files and dataMap!")
}

// Clean enum folder.
func cleanEnumFolder() {
	enumDir := "internal/db/gen/enum"
	if err := os.RemoveAll(enumDir); err != nil {
		log.Fatalf("failed to remove directory %s: %v", enumDir, err)
	}

	fmt.Println("✅ Successfully cleaned enum folder")
}

func fetchCustomTypes(db *gorm.DB) ([]PostgresType, error) {
	sqlDB, err := db.DB()
	if err != nil {
		return nil, fmt.Errorf("failed to get sql.DB: %w", err)
	}

	// Query to get all custom enum types and their values
	query := `
		SELECT
			t.typname as type_name,
			string_agg(e.enumlabel, ',' ORDER BY e.enumsortorder) as enum_values
		FROM pg_type t
		JOIN pg_enum e ON t.oid = e.enumtypid
		JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
		WHERE n.nspname = 'public'
		GROUP BY t.typname
		ORDER BY t.typname;
	`

	rows, err := sqlDB.Query(query)
	if err != nil {
		return nil, fmt.Errorf("failed to execute query: %w", err)
	}
	defer func() {
		if err := rows.Close(); err != nil {
			log.Printf("failed to close rows: %v", err)
		}
	}()

	var types []PostgresType
	for rows.Next() {
		var typeName, enumValues string
		if err := rows.Scan(&typeName, &enumValues); err != nil {
			return nil, fmt.Errorf("failed to scan row: %w", err)
		}

		values := strings.Split(enumValues, ",")
		types = append(types, PostgresType{
			TypeName: typeName,
			Values:   values,
		})
	}

	if err := rows.Err(); err != nil {
		return nil, fmt.Errorf("row iteration error: %w", err)
	}

	return types, nil
}

func generateStructFiles(types []PostgresType) error {
	// Ensure the enum directory exists
	modelStructDir := "internal/db/gen/enum"
	if err := os.MkdirAll(modelStructDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", modelStructDir, err)
	}

	for _, pgType := range types {
		if err := generateSingleStructFile(pgType, modelStructDir); err != nil {
			return fmt.Errorf("failed to generate struct file for %s: %w", pgType.TypeName, err)
		}
	}

	return nil
}

func generateSingleStructFile(pgType PostgresType, outputDir string) error {
	// Convert snake_case to PascalCase for Go type name
	goTypeName := toPascalCase(pgType.TypeName)

	// Create new jen file
	f := jen.NewFile("enum")

	// Add import for database/sql/driver
	f.ImportName("database/sql/driver", "driver")

	// Create the type definition
	f.Type().Id(goTypeName).String()

	// Create constants
	f.Const().DefsFunc(func(g *jen.Group) {
		for _, value := range pgType.Values {
			constName := goTypeName + toPascalCase(strings.ToLower(value))
			g.Id(constName).Id(goTypeName).Op("=").Lit(value)
		}
	})

	// Add Scan method for database/sql/driver.Valuer interface
	f.Func().
		Params(jen.Id("s").Op("*").Id(goTypeName)).
		Id("Scan").
		Params(jen.Id("value").Interface()).
		Error().
		Block(
			jen.Op("*").Id("s").Op("=").Id(goTypeName).Call(jen.Id("value").Assert(jen.String())),
			jen.Return(jen.Nil()),
		)

	// Add Value method for database/sql/driver.Valuer interface
	f.Func().
		Params(jen.Id("s").Id(goTypeName)).
		Id("Value").
		Params().
		Params(jen.Qual("database/sql/driver", "Value"), jen.Error()).
		Block(
			jen.Return(jen.String().Call(jen.Id("s")), jen.Nil()),
		)

	// Write to file
	filename := fmt.Sprintf("%s.go", pgType.TypeName)
	filepath := filepath.Join(outputDir, filename)

	if err := f.Save(filepath); err != nil {
		return fmt.Errorf("failed to save file %s: %w", filepath, err)
	}

	fmt.Printf("✅ Generated: %s\n", filepath)
	return nil
}

func generateDataMap(types []PostgresType) error {
	// Create new jen file for dataMap
	f := jen.NewFile("datamap")

	f.HeaderComment("Code generated by cmd/model/generate.go. DO NOT EDIT.")

	// Add necessary imports
	f.ImportName("gorm.io/gorm", "gorm")

	// Add package comment
	f.Comment("Package datamap provides PostgreSQL to Go type mappings for GORM gen")
	f.Line()

	// Create DataMapEntry struct
	f.Comment("DataMapEntry represents a mapping from PostgreSQL type to Go type")
	f.Type().Id("DataMapEntry").Struct(
		jen.Id("PostgresType").String(),
		jen.Id("GoType").String(),
	)
	f.Line()

	// Create the GetDataMapEntries function
	f.Comment("GetDataMapEntries returns all the type mappings for PostgreSQL to Go types")
	f.Func().Id("GetDataMapEntries").Params().Index().Id("DataMapEntry").Block(
		jen.Return(jen.Index().Id("DataMapEntry").ValuesFunc(func(g *jen.Group) {
			// Add entries for custom types
			for _, pgType := range types {
				goTypeName := toPascalCase(pgType.TypeName)
				g.Values(jen.Dict{
					jen.Id("PostgresType"): jen.Lit(pgType.TypeName),
					jen.Id("GoType"):       jen.Lit("enum." + goTypeName),
				})
			}

			// Add common PostgreSQL type mappings
			commonTypes := []DataMapEntry{
				{"text[]", "pq.StringArray"},
				{"jsonb", "[]byte"},
				{"json", "[]byte"},
				{"uuid", "uuid.UUID"},
			}

			for _, entry := range commonTypes {
				g.Values(jen.Dict{
					jen.Id("PostgresType"): jen.Lit(entry.PostgresType),
					jen.Id("GoType"):       jen.Lit(entry.GoType),
				})
			}
		})),
	)
	f.Line()

	// Create the BuildDataMap function
	f.Comment("BuildDataMap creates the dataMap for GORM gen to use for type mapping")
	f.Func().Id("BuildDataMap").Params().Map(jen.String()).Func().
		Params(jen.Qual("gorm.io/gorm", "ColumnType")).
		Params(jen.Id("dataType").String()).
		Block(
			jen.Id("dataMap").Op(":=").Make(jen.Map(jen.String()).Func().
				Params(jen.Qual("gorm.io/gorm", "ColumnType")).
				Params(jen.Id("dataType").String())),
			jen.Line(),
			jen.Id("entries").Op(":=").Id("GetDataMapEntries").Call(),
			jen.For(jen.List(jen.Id("_"), jen.Id("entry")).Op(":=").Range().Id("entries")).Block(
				jen.Comment("Create a closure to capture the entry value"),
				jen.Id("goType").Op(":=").Id("entry").Dot("GoType"),
				jen.Id("dataMap").Index(jen.Id("entry").Dot("PostgresType")).Op("=").Func().
					Params(jen.Id("columnType").Qual("gorm.io/gorm", "ColumnType")).
					Params(jen.Id("dataType").String()).
					Block(
						jen.Return(jen.Id("goType")),
					),
			),
			jen.Line(),
			jen.Return(jen.Id("dataMap")),
		)

		// Ensure the datamap directory exists
	enumDir := "internal/db/gen/datamap"
	if err := os.MkdirAll(enumDir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", enumDir, err)
	}

	// Write to file
	filepath := "internal/db/gen/datamap/datamap.go"
	if err := f.Save(filepath); err != nil {
		return fmt.Errorf("failed to save dataMap file: %w", err)
	}

	fmt.Printf("✅ Generated: %s\n", filepath)
	return nil
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + strings.ToLower(part[1:])
		}
	}
	return strings.Join(parts, "")
}
